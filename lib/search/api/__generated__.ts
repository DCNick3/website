/**
 * Generated by orval v6.29.1 üç∫
 * Do not edit manually.
 * InNoHassle-Search
 * 
### About this project

 * OpenAPI spec version: 0.1.0
 */
import { useMutation, useQuery } from "@tanstack/react-query";
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query";
import { axiosQuery } from "./axios";
import { queryOptionsMutator } from "./query";
export type MoodlePreviewMoodleParams = {
  course_id: number;
  module_id: number;
  filename: string;
};

export type SearchSearchByMetaParams = {
  query: string;
  limit?: number;
};

export type ValidationErrorLocItem = string | number;

export interface ValidationError {
  loc: ValidationErrorLocItem[];
  msg: string;
  type: string;
}

export type TelegramSourceType =
  (typeof TelegramSourceType)[keyof typeof TelegramSourceType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TelegramSourceType = {
  telegram: "telegram",
} as const;

export interface TelegramSource {
  /** Breadcrumbs to the resource. */
  breadcrumbs: string[];
  /** Title of the chat, channel, group */
  chat_title: string;
  /** Username of the chat, channel, group */
  chat_username: string;
  /** Display name of the resource. */
  display_name: string;
  /** Link to the message */
  link: string;
  /** Message ID in the chat */
  message_id: number;
  type: TelegramSourceType;
}

export interface SearchResponses {
  /** Responses to the search query. */
  responses: SearchResponse[];
  /** Text that was searched for. */
  searched_for: string;
}

/**
 * Score of the search response. Optional.
 */
export type SearchResponseScore = number | null;

export interface PdfLocation {
  /** Page index in the PDF file. Starts from 1. */
  page_index: number;
}

export type MoodleSourceType =
  (typeof MoodleSourceType)[keyof typeof MoodleSourceType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MoodleSourceType = {
  moodle: "moodle",
} as const;

export type MoodleSourcePreviewLocation = PdfLocation | null;

/**
 * Filename of the resource.
 */
export type MoodleSourceFilename = string | null;

export interface MoodleSource {
  /** Breadcrumbs to the resource. */
  breadcrumbs: string[];
  /** Course ID in the Moodle system. */
  course_id: number;
  /** Course name in the Moodle system. */
  course_name: string;
  /** Display name of the resource. */
  display_name: string;
  /** Filename of the resource. */
  filename: MoodleSourceFilename;
  /** Anchor URL to the resource on Moodle. */
  link: string;
  /** Module ID in the Moodle system (resources). */
  module_id: number;
  /** Module name in the Moodle system. */
  module_name: string;
  preview_location: MoodleSourcePreviewLocation;
  /** URL to download the resource. */
  resource_download_url: string;
  /** URL to get the preview of the resource. */
  resource_preview_url: string;
  /** Type of the resource. */
  resource_type: string;
  type: MoodleSourceType;
}

/**
 * Relevant source for the search.
 */
export type SearchResponseSource = MoodleSource | TelegramSource;

export interface SearchResponse {
  /** Score of the search response. Optional. */
  score: SearchResponseScore;
  /** Relevant source for the search. */
  source: SearchResponseSource;
}

export interface MoodleEntry {
  contents: MoodleContentSchemaOutput[];
  course_fullname: string;
  course_id: number;
  /** MongoDB document ObjectID */
  id: string;
  module_id: number;
  module_modname: string;
  module_name: string;
}

export interface MoodleCourse {
  course_id: number;
  coursecategory: string;
  enddate: number;
  fullname: string;
  /** MongoDB document ObjectID */
  id: string;
  startdate: number;
}

export type MoodleContentSchemaOutputTimemodified = number | null;

export type MoodleContentSchemaOutputTimecreated = number | null;

export interface MoodleContentSchemaOutput {
  filename: string;
  timecreated: MoodleContentSchemaOutputTimecreated;
  timemodified: MoodleContentSchemaOutputTimemodified;
  type: string;
}

export type MoodleContentSchemaInputTimemodified = number | null;

export type MoodleContentSchemaInputTimecreated = number | null;

export interface MoodleContentSchemaInput {
  filename: string;
  timecreated?: MoodleContentSchemaInputTimecreated;
  timemodified?: MoodleContentSchemaInputTimemodified;
  type: string;
}

export interface InModule {
  contents?: MoodleContentSchemaInput[];
  id: number;
  modname: string;
  name: string;
}

export interface InSection {
  id: number;
  modules: InModule[];
  summary: string;
}

export interface InSections {
  course_fullname: string;
  course_id: number;
  sections: InSection[];
}

export interface InCourse {
  coursecategory: string;
  enddate: number;
  fullname: string;
  id: number;
  startdate: number;
}

export interface InCourses {
  courses: InCourse[];
}

export interface InContentsOutput {
  contents: MoodleContentSchemaOutput[];
  course_id: number;
  module_id: number;
}

export interface InContentsInput {
  contents: MoodleContentSchemaInput[];
  course_id: number;
  module_id: number;
}

export interface HTTPValidationError {
  detail?: ValidationError[];
}

export interface BodyMoodleUploadContent {
  data: InContentsInput;
  files: Blob[];
}

type SecondParameter<T extends (...args: any) => any> = Parameters<T>[1];

/**
 * @summary Search By Meta
 */
export const searchSearchByMeta = (
  params: SearchSearchByMetaParams,
  options?: SecondParameter<typeof axiosQuery>,
  signal?: AbortSignal,
) => {
  return axiosQuery<SearchResponses>(
    { url: `/search/by-meta`, method: "GET", params, signal },
    options,
  );
};

export const getSearchSearchByMetaQueryKey = (
  params: SearchSearchByMetaParams,
) => {
  return [`/search/by-meta`, ...(params ? [params] : [])] as const;
};

export const useSearchSearchByMetaQueryOptions = <
  TData = Awaited<ReturnType<typeof searchSearchByMeta>>,
  TError = HTTPValidationError,
>(
  params: SearchSearchByMetaParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof searchSearchByMeta>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof axiosQuery>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getSearchSearchByMetaQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof searchSearchByMeta>>
  > = ({ signal }) => searchSearchByMeta(params, requestOptions, signal);

  const customOptions = queryOptionsMutator({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseQueryOptions<
    Awaited<ReturnType<typeof searchSearchByMeta>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type SearchSearchByMetaQueryResult = NonNullable<
  Awaited<ReturnType<typeof searchSearchByMeta>>
>;
export type SearchSearchByMetaQueryError = HTTPValidationError;

/**
 * @summary Search By Meta
 */
export const useSearchSearchByMeta = <
  TData = Awaited<ReturnType<typeof searchSearchByMeta>>,
  TError = HTTPValidationError,
>(
  params: SearchSearchByMetaParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof searchSearchByMeta>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof axiosQuery>;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = useSearchSearchByMetaQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary Preview Moodle
 */
export const moodlePreviewMoodle = (
  params: MoodlePreviewMoodleParams,
  options?: SecondParameter<typeof axiosQuery>,
  signal?: AbortSignal,
) => {
  return axiosQuery<unknown>(
    { url: `/moodle/preview`, method: "GET", params, signal },
    options,
  );
};

export const getMoodlePreviewMoodleQueryKey = (
  params: MoodlePreviewMoodleParams,
) => {
  return [`/moodle/preview`, ...(params ? [params] : [])] as const;
};

export const useMoodlePreviewMoodleQueryOptions = <
  TData = Awaited<ReturnType<typeof moodlePreviewMoodle>>,
  TError = void | HTTPValidationError,
>(
  params: MoodlePreviewMoodleParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof moodlePreviewMoodle>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof axiosQuery>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getMoodlePreviewMoodleQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof moodlePreviewMoodle>>
  > = ({ signal }) => moodlePreviewMoodle(params, requestOptions, signal);

  const customOptions = queryOptionsMutator({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseQueryOptions<
    Awaited<ReturnType<typeof moodlePreviewMoodle>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type MoodlePreviewMoodleQueryResult = NonNullable<
  Awaited<ReturnType<typeof moodlePreviewMoodle>>
>;
export type MoodlePreviewMoodleQueryError = void | HTTPValidationError;

/**
 * @summary Preview Moodle
 */
export const useMoodlePreviewMoodle = <
  TData = Awaited<ReturnType<typeof moodlePreviewMoodle>>,
  TError = void | HTTPValidationError,
>(
  params: MoodlePreviewMoodleParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof moodlePreviewMoodle>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof axiosQuery>;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = useMoodlePreviewMoodleQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary Batch Upsert Courses
 */
export const moodleBatchUpsertCourses = (
  inCourses: InCourses,
  options?: SecondParameter<typeof axiosQuery>,
) => {
  return axiosQuery<unknown>(
    {
      url: `/moodle/batch-courses`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: inCourses,
    },
    options,
  );
};

export const getMoodleBatchUpsertCoursesMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof moodleBatchUpsertCourses>>,
    TError,
    { data: InCourses },
    TContext
  >;
  request?: SecondParameter<typeof axiosQuery>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof moodleBatchUpsertCourses>>,
  TError,
  { data: InCourses },
  TContext
> => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof moodleBatchUpsertCourses>>,
    { data: InCourses }
  > = (props) => {
    const { data } = props ?? {};

    return moodleBatchUpsertCourses(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type MoodleBatchUpsertCoursesMutationResult = NonNullable<
  Awaited<ReturnType<typeof moodleBatchUpsertCourses>>
>;
export type MoodleBatchUpsertCoursesMutationBody = InCourses;
export type MoodleBatchUpsertCoursesMutationError = HTTPValidationError;

/**
 * @summary Batch Upsert Courses
 */
export const useMoodleBatchUpsertCourses = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof moodleBatchUpsertCourses>>,
    TError,
    { data: InCourses },
    TContext
  >;
  request?: SecondParameter<typeof axiosQuery>;
}): UseMutationResult<
  Awaited<ReturnType<typeof moodleBatchUpsertCourses>>,
  TError,
  { data: InCourses },
  TContext
> => {
  const mutationOptions = getMoodleBatchUpsertCoursesMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Courses
 */
export const moodleCourses = (
  options?: SecondParameter<typeof axiosQuery>,
  signal?: AbortSignal,
) => {
  return axiosQuery<MoodleCourse[]>(
    { url: `/moodle/courses`, method: "GET", signal },
    options,
  );
};

export const getMoodleCoursesQueryKey = () => {
  return [`/moodle/courses`] as const;
};

export const useMoodleCoursesQueryOptions = <
  TData = Awaited<ReturnType<typeof moodleCourses>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof moodleCourses>>, TError, TData>
  >;
  request?: SecondParameter<typeof axiosQuery>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getMoodleCoursesQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof moodleCourses>>> = ({
    signal,
  }) => moodleCourses(requestOptions, signal);

  const customOptions = queryOptionsMutator({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseQueryOptions<
    Awaited<ReturnType<typeof moodleCourses>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type MoodleCoursesQueryResult = NonNullable<
  Awaited<ReturnType<typeof moodleCourses>>
>;
export type MoodleCoursesQueryError = unknown;

/**
 * @summary Courses
 */
export const useMoodleCourses = <
  TData = Awaited<ReturnType<typeof moodleCourses>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof moodleCourses>>, TError, TData>
  >;
  request?: SecondParameter<typeof axiosQuery>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = useMoodleCoursesQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary Course Content
 */
export const moodleCourseContent = (
  inSections: InSections,
  options?: SecondParameter<typeof axiosQuery>,
) => {
  return axiosQuery<unknown>(
    {
      url: `/moodle/set-course-content`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: inSections,
    },
    options,
  );
};

export const getMoodleCourseContentMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof moodleCourseContent>>,
    TError,
    { data: InSections },
    TContext
  >;
  request?: SecondParameter<typeof axiosQuery>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof moodleCourseContent>>,
  TError,
  { data: InSections },
  TContext
> => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof moodleCourseContent>>,
    { data: InSections }
  > = (props) => {
    const { data } = props ?? {};

    return moodleCourseContent(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type MoodleCourseContentMutationResult = NonNullable<
  Awaited<ReturnType<typeof moodleCourseContent>>
>;
export type MoodleCourseContentMutationBody = InSections;
export type MoodleCourseContentMutationError = HTTPValidationError;

/**
 * @summary Course Content
 */
export const useMoodleCourseContent = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof moodleCourseContent>>,
    TError,
    { data: InSections },
    TContext
  >;
  request?: SecondParameter<typeof axiosQuery>;
}): UseMutationResult<
  Awaited<ReturnType<typeof moodleCourseContent>>,
  TError,
  { data: InSections },
  TContext
> => {
  const mutationOptions = getMoodleCourseContentMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Courses Content
 */
export const moodleCoursesContent = (
  options?: SecondParameter<typeof axiosQuery>,
  signal?: AbortSignal,
) => {
  return axiosQuery<MoodleEntry[]>(
    { url: `/moodle/courses-content`, method: "GET", signal },
    options,
  );
};

export const getMoodleCoursesContentQueryKey = () => {
  return [`/moodle/courses-content`] as const;
};

export const useMoodleCoursesContentQueryOptions = <
  TData = Awaited<ReturnType<typeof moodleCoursesContent>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof moodleCoursesContent>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof axiosQuery>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getMoodleCoursesContentQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof moodleCoursesContent>>
  > = ({ signal }) => moodleCoursesContent(requestOptions, signal);

  const customOptions = queryOptionsMutator({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseQueryOptions<
    Awaited<ReturnType<typeof moodleCoursesContent>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type MoodleCoursesContentQueryResult = NonNullable<
  Awaited<ReturnType<typeof moodleCoursesContent>>
>;
export type MoodleCoursesContentQueryError = unknown;

/**
 * @summary Courses Content
 */
export const useMoodleCoursesContent = <
  TData = Awaited<ReturnType<typeof moodleCoursesContent>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof moodleCoursesContent>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof axiosQuery>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = useMoodleCoursesContentQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary Need To Upload Contents
 */
export const moodleNeedToUploadContents = (
  inContentsInput: InContentsInput[],
  options?: SecondParameter<typeof axiosQuery>,
) => {
  return axiosQuery<InContentsOutput[]>(
    {
      url: `/moodle/need-to-upload-contents`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: inContentsInput,
    },
    options,
  );
};

export const getMoodleNeedToUploadContentsMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof moodleNeedToUploadContents>>,
    TError,
    { data: InContentsInput[] },
    TContext
  >;
  request?: SecondParameter<typeof axiosQuery>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof moodleNeedToUploadContents>>,
  TError,
  { data: InContentsInput[] },
  TContext
> => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof moodleNeedToUploadContents>>,
    { data: InContentsInput[] }
  > = (props) => {
    const { data } = props ?? {};

    return moodleNeedToUploadContents(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type MoodleNeedToUploadContentsMutationResult = NonNullable<
  Awaited<ReturnType<typeof moodleNeedToUploadContents>>
>;
export type MoodleNeedToUploadContentsMutationBody = InContentsInput[];
export type MoodleNeedToUploadContentsMutationError = HTTPValidationError;

/**
 * @summary Need To Upload Contents
 */
export const useMoodleNeedToUploadContents = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof moodleNeedToUploadContents>>,
    TError,
    { data: InContentsInput[] },
    TContext
  >;
  request?: SecondParameter<typeof axiosQuery>;
}): UseMutationResult<
  Awaited<ReturnType<typeof moodleNeedToUploadContents>>,
  TError,
  { data: InContentsInput[] },
  TContext
> => {
  const mutationOptions = getMoodleNeedToUploadContentsMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * @summary Upload Content
 */
export const moodleUploadContent = (
  bodyMoodleUploadContent: BodyMoodleUploadContent,
  options?: SecondParameter<typeof axiosQuery>,
) => {
  const formData = new FormData();
  bodyMoodleUploadContent.files.forEach((value) =>
    formData.append("files", value),
  );
  formData.append("data", bodyMoodleUploadContent.data);

  return axiosQuery<unknown>(
    {
      url: `/moodle/upload-contents`,
      method: "POST",
      headers: { "Content-Type": "multipart/form-data" },
      data: formData,
    },
    options,
  );
};

export const getMoodleUploadContentMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof moodleUploadContent>>,
    TError,
    { data: BodyMoodleUploadContent },
    TContext
  >;
  request?: SecondParameter<typeof axiosQuery>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof moodleUploadContent>>,
  TError,
  { data: BodyMoodleUploadContent },
  TContext
> => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof moodleUploadContent>>,
    { data: BodyMoodleUploadContent }
  > = (props) => {
    const { data } = props ?? {};

    return moodleUploadContent(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type MoodleUploadContentMutationResult = NonNullable<
  Awaited<ReturnType<typeof moodleUploadContent>>
>;
export type MoodleUploadContentMutationBody = BodyMoodleUploadContent;
export type MoodleUploadContentMutationError = HTTPValidationError;

/**
 * @summary Upload Content
 */
export const useMoodleUploadContent = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof moodleUploadContent>>,
    TError,
    { data: BodyMoodleUploadContent },
    TContext
  >;
  request?: SecondParameter<typeof axiosQuery>;
}): UseMutationResult<
  Awaited<ReturnType<typeof moodleUploadContent>>,
  TError,
  { data: BodyMoodleUploadContent },
  TContext
> => {
  const mutationOptions = getMoodleUploadContentMutationOptions(options);

  return useMutation(mutationOptions);
};
